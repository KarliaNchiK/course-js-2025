### 1. Почему в Vue 3 состояние живёт в `setup`, а не в `data`

В Vue 2 опция `data` должна быть функцией, возвращающей объект, чтобы каждый экземпляр компонента имел своё изолированное состояние. Если сделать `data` объектом, все компоненты начнут делить одно состояние — как общий блокнот для всей группы студентов. Это хаос!

В Vue 3 с Composition API мы уходим от `data` и определяем состояние в функции `setup`. Здесь мы используем `ref` для отдельных значений или `reactive` для объектов. `setup` вызывается для каждого экземпляра, гарантируя изоляцию.

**Пример:**

```javascript
import { ref } from 'vue';

export default {
  setup() {
    const text = ref('');
    return { text };
  }
}
```

- **Зачем?** Чтобы каждый компонент получил свою "тетрадь" состояния.
- **Аналогия:** Представьте, что `setup` — это персональный рюкзак, в который вы кладёте свои вещи (состояние), и никто другой не может их взять.

---

### 2. Реактивность в Vue 3: магия Proxy

Реактивность — это сердце Vue, которое автоматически синхронизирует данные и интерфейс. В Vue 2 это делалось через `Object.defineProperty`, но у него были ограничения: новые свойства не становились реактивными, а массивы требовали специальных методов.

В Vue 3 реактивность основана на **Proxy** — современном механизме JavaScript. Proxy перехватывает все операции с объектом, делая его полностью реактивным, включая новые свойства.

**Пример:**

```javascript
import { reactive } from 'vue';

export default {
  setup() {
    const state = reactive({
      name: 'Kimi',
      number: 42
    });
    return { state };
  }
}
```

- **Что изменилось?**
  - Добавили `state.newProp = 'test'` — оно автоматически реактивно!
  - Массивы лучше отслеживаются, хотя для прямой замены по индексу всё ещё лучше использовать методы вроде `splice`.

- **Аналогия:** Если Vue 2 — это библиотекарь, который вручную записывает изменения в журнал, то Vue 3 — это умный робот, который мгновенно обновляет всё сам.

Документация по `vue` гласит:

> В каждый экземпляр компонента добавлен связанный с ним экземпляр наблюдателя,
> который помечает все поля, затронутые при отрисовке компонента как зависимости.
> В дальнейшем, когда вызывается сеттер поля, помеченного как зависимость, этот сеттер
> уведомляет наблюдателя, который, в свою очередь, инициирует
> повторную отрисовку компонента.

![reactivity](./assets/reactivity.png)

---

### 3. MVVM и Vue: как всё связано

Vue следует паттерну **MVVM (Model-View-ViewModel)**:
- **Model** — данные (состояние в `setup`).
- **View** — шаблон в `<template>`.
- **ViewModel** — сам Vue, который связывает их через реактивность.

![mvvm](./assets/mvvm.png)

В данном случае сам `Vue` является `ViewModel`-частью концепции, определяя способ
синхронизации слоя данных (`Model`) и слоя представления (`View`). <br>
`Vue` реактивно связывает модель и слой представления, благодаря чему мы (разработчики)
можем обновлять состояние и знать, что слой представления обновится автоматически, и
наоборот, что при обновлении слоя представления (например, через `v-model`) автоматически
обновится слой данных.

Composition API не меняет эту концепцию, но делает код гибче: вы группируете логику по смыслу, а не по типу опций.

**Пример:** Реактивное состояние в `setup` — это Model, а шаблон — View.

---

### 4. MVC и Vue: возможно ли?

**MVC (Model-View-Controller)** — менее точная модель для Vue, но можно представить:
- **Model** — состояние в `setup`.
- **View** — шаблон.
- **Controller** — логика в `setup` (методы, события).

Vue больше про MVVM, но Composition API позволяет разделять логику так, что она напоминает Controller. Однако это лишь интерпретация — официально Vue остаётся MVVM-фреймворком.

---

### 5. Virtual DOM: невидимый помощник

Vue использует **Virtual DOM**, чтобы минимизировать прямые изменения в реальном DOM. При обновлении состояния создаётся виртуальная копия DOM, сравнивается с текущей, и обновляются только изменённые части.

**В Vue 3:** Virtual DOM стал ещё быстрее благодаря оптимизациям, но принцип тот же.

- **Аналогия:** Это как черновик письма: вы пишете его, сравниваете с оригиналом и исправляете только нужные строки.

![virtual-dom](./assets/virtual-dom.jpg)

---

### 6. Дерево компонентов: пропсы, события и provide/inject

Компоненты образуют дерево, где данные передаются через:
- **Пропсы** — от родителя к ребёнку.
- **События** — от ребёнка к родителю.

**В Composition API:**
- Пропсы доступны через аргумент `props` в `setup`.
- События отправляются через `emit`.

**Пример:**

```javascript
export default {
  props: {
    manoolItems: {
      type: Array,
      default: () => []
    }
  },
  emits: ['remove'],
  setup(props, { emit }) {
    const removeItem = (index) => {
      emit('remove', index);
    };

    return { removeItem };
  }
}
```

```vue
<script setup>
  const props = defineProps({
    manoolItems: {
      type: Array,
      default: () => []
    },
  });
  
  const emit = defineEmits([
      'remove',
  ]);

  const removeItem = (index) => {
    emit('remove', index);
  };
</script>
```

**Provide / Inject**
Для передачи данных через несколько уровней используйте `provide` и `inject`:

```vue
// Родитель
<script setup>
  import { provide, reactive } from 'vue';

  provide('sharedData', 'Hello from parent');
  
  const item = reactive({ id: 4 });
  provide('itemData', 'Hello from parent');
</script>

// Ребёнок
<script setup>
  import { inject } from 'vue';

  const data = inject('sharedData');
  const item = inject('itemData');
</script>
```

- **Аналогия:** Пропсы и события — это письма между соседями, а `provide/inject` — радиоволны, доступные всем в доме.

---

### 7. Пропсы: всё, что нужно знать

Пропсы в Vue 3 определяются так же, как в Vue 2, но с улучшенной поддержкой TypeScript.

**Пример:**

```javascript
import { defineComponent, PropType } from 'vue';

export default defineComponent({
  props: {
    manoolItems: {
      type: Array as PropType<string[]>,
      default: () => []
    }
  },
  setup(props) {
    console.log(props.manoolItems); // Тип string[]
  }
});
```

- **Опции:** `type`, `default`, `required`, `validator` — всё как раньше.
- **Совет:** Используйте TypeScript для точной типизации.

---

### 8. Стили: `scoped` против `common`

- **Без `scoped`:** Стили глобальны.
- **С `scoped`:** Стили только для компонента (Vue добавляет уникальные атрибуты).

**Пример:**

```html
<style scoped>
.satellite { margin: 20px; }
</style>
```

---

### 9. Следим за изменениями: `watch` и `watchEffect`

**`watch`:** Отслеживает конкретные данные.

```javascript
import { ref, watch } from 'vue';

export default {
  setup() {
    const count = ref(0);
    watch(count, (newVal) => {
      if (newVal > 10) alert('Больше 10!');
    });
    return { count };
  }
}
```

**`watchEffect`:** Автоматически следит за зависимостями.

```javascript
import { watchEffect } from 'vue';

export default {
  setup() {
    const count = ref(0);
    watchEffect(() => {
      if (count.value > 10) alert('Больше 10!');
    });
    return { count };
  }
}
```

- **Аналогия:** `watch` — это будильник на конкретное время, `watchEffect` — датчик движения, реагирующий на всё.

---
